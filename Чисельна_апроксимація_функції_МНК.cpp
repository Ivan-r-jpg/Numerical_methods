// Чисельна_апроксимація_функції_МНК.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

// Підключення бібліотек
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <conio.h>
#include <Windows.h>

typedef struct point { // Структура для зберігання властивості точки
	float x; // Точка х
	float y; // Точка y
} point;  

typedef struct table { // Структура для зберігання властивостей таблиці
	float x_average; // X-cер.
	float y_average; // Y-сер.
	float y_regressive; // Y-рег.
	float module; // Модуль
	int number; // Порядоквий номер в таблиці
};

float sum_x(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження суми експериментальних даних по x

float sum_y(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження суми експериментальних даних по y

float sum_of_product(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження суми добутків експериментальних даних по x та y

float sum_of_xsquares(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження суми квадратів експериментальних даних по x

float sum_of_ysquares(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження суми квадратів експериментальних даних по y

void sorting_up(point* arr_arg, int n_arg); // Прототип функції, необхідної для сортування масиву за зростанням

void sorting_down(point* arr_arg, int n_arg); // Прототип функції, необхідної для сортування масиву за спаданням

float average_x(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього арифметичного експериментальних даних по x

float average_y(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього арифметичного експериментальних даних по y

float average_geometric_x(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього геометричного експериментальних даних по x

float average_geometric_y(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього геометричного експериментальних даних по y

float average_garmonic_x(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього гармонійного експериментальних даних по x

float average_garmonic_y(point* arr_arg, int n_arg); // Прототип функцій, необхідної для знаходження середнього гармонійного експериментальних даних по y

void search(table array_arg[], point* arr_arg, int n_arg); // Прототип функції, необхідної для пошуку Y-регресивного та модуля

int find_min(table array_arg[]); // Прототип функції, необхідної для пошуку мінімального за значенням модуля

void calculating_a1_a0(point* tmparr_arg, int n_arg, float* a1_arg, float* a0_arg); // Прототип функції, необхідної для знаходження коефіцієнтів a1 та a0

void process(table array_arg[], point* arr_arg, int n_arg, int index_arg); // Прототип функції, необхідної для визначення типу функції регресії та виводу результатів

int main() // Головна функція
{
	// Встановлення кодування Windows-1251
	SetConsoleOutputCP(1251); 
	SetConsoleCP(1251);
	point *arr; 
	table array[9];
	int n, choice, index;
	puts("\t\t\t\t~~ЧИСЕЛЬНА АПРОКСИМАЦІЯ ФУНКЦІЇ ЗА МНК~~");
	puts("\n-----------------------------------------------------------------------------------------");
	printf("[УВАГА] - Введіть кількість точок, що підлягають дослідженню: ");
	scanf_s("%d", &n);
	puts("-----------------------------------------------------------------------------------------");
	// Перевірка кількості введених точок
	while (n < 2)
	{
		puts("\n-----------------------------------------------------------------------------------------");
		printf("[УВАГА] - Введіть правильну кількість експериментальних точок: ");
		scanf_s("%d", &n);
		puts("-----------------------------------------------------------------------------------------");
	}
	arr = (point*)malloc(n * sizeof(point)); // Виділення пам'яті для масиву точок
	// Перевірка виділення пам'яті
	if (arr == NULL)
	{
		puts("\n-----------------------------------------------------------------------------------------");
		puts("[ПОМИЛКА] - Невдале виділення пам'яті!");
		puts("-----------------------------------------------------------------------------------------");
		exit(1); // Завершення програми з кодом помилки
	}
	puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	puts("\t\t\t\t~~ВВЕДЕННЯ ЕКСПЕРИМЕНТАЛЬНИХ ДАНИХ~~");
	puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	// Введення експериментальних точок
	for (int i = 0; i < n; i++)
	{
		printf("\n[x(%d)] = ", i + 1);
		scanf_s("%f", &arr[i].x);
		printf("\n[y(%d)] = ", i + 1);
		scanf_s("%f", &arr[i].y);
	}
	puts("\n-----------------------------------------------------------------------------------------");
	puts("[УВАГА] - Оберіть тип поведінки функції:\n>1< - Спадаюча\n\n>2< - Зростаюча");
	puts("-----------------------------------------------------------------------------------------");
	puts("\n-----------------------------------------------------------------------------------------");
	printf("Введіть ваш вибір: ");
	scanf_s("%d", &choice);
	puts("-----------------------------------------------------------------------------------------");
	// Перевірка вводу користувача
	while (choice != 1 && choice != 2)
	{
		puts("\n-----------------------------------------------------------------------------------------");
		printf("[УВАГА] - Оберіть ще раз тип поведінки функції : \n >1< -Спадає на інтервалі[% .3f; % .3f]\n\n>2< -Зростає на інтервалі[% .3f; % .3f]\n", arr[0].x, arr[n - 1].x, arr[0].x, arr[n - 1].x);
		scanf_s("%d", &choice);
		puts("-----------------------------------------------------------------------------------------");
	}
	// Сортування експериментальних даних за значенням х
	if (choice == 1)
	{
		sorting_down(arr, n);
		puts("\n-----------------------------------------------------------------------------------------");
		printf("[УВАГА] - Дані відсортовано за спаданням!\nФункція монотонно спадає на проміжку х є [%.3f; %.3f]\n", arr[0].x, arr[n - 1].x);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (choice == 2)
	{
		sorting_up(arr, n);
		puts("\n-----------------------------------------------------------------------------------------");
		printf("[УВАГА] - Дані відсортовано за зростанням!\nФункція монотонно зростає на проміжку х є [%.3f; %.3f]\n", arr[0].x, arr[n - 1].x);
		puts("-----------------------------------------------------------------------------------------");
	}
	puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	puts("\t\t\t\t~~ЕКСПЕРИМЕНТАЛЬНІ ДАНІ~~");
	puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	puts("\n\t -----------------------------------------------");
	// Виведення експериментальних точок на екран
	for (int i = 0; i < n; i++)
	{
		printf("\t|\tx: %.3f\t|\ty: %.3f\t|\n", arr[i].x, arr[i].y);
	}
	puts("\t -----------------------------------------------");
	puts("\n-----------------------------------------------------------------------------------------");
	puts("[УВАГА] - Розрахунок X_сер., Y_сер., Y_рег., та значення відносної похибки моделі...");
	puts("-----------------------------------------------------------------------------------------");
	// Заповнення таблиці значеннями
	for (int i = 0; i < 9; i++)
	{
		array[i].number = i + 1;

		// Заповнення колонки X-сер.
		if (array[i].number == 1 || array[i].number == 4 || array[i].number == 7)
		{
			array[i].x_average = average_x(arr, n);
		}
		else if (array[i].number == 2 || array[i].number == 5 || array[i].number == 8)
		{
			array[i].x_average = average_geometric_x(arr, n);
		}
		else 
		{
			array[i].x_average = average_garmonic_x(arr, n);
		}
		// Заповнення колонки Y-сер.
		if (array[i].number == 1 || array[i].number == 2 || array[i].number == 3)
		{
			array[i].y_average = average_y(arr, n);
		}
		else if (array[i].number == 4 || array[i].number == 5 || array[i].number == 6)
		{
			array[i].y_average = average_geometric_y(arr, n);
		}
		else 
		{
			array[i].y_average = average_garmonic_y(arr, n);
		}
	}
	search(array, arr, n); // Розрахунок Y-рег. для кожного рядка таблиці
	puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	puts("\t\t\t\t~~ТАБЛИЦЯ РЕЗУЛЬТАТІВ~~");
	puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
	puts("\t ---------------------------------------------------------------------------------------");
	printf("\t|\t№\t|\tХ_сер.\t|\tY_сер.\t|\tY_рег.\t|Відносна похибка моделі|\n");
	puts("\t ---------------------------------------------------------------------------------------");
	// Виведення значень таблиці на екран
	for (int i = 0; i < 9; i++)
	{
		printf("\t|\t%d\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t\t|\n", array[i].number, array[i].x_average, array[i].y_average, array[i].y_regressive, array[i].module);
	}
	puts("\t ---------------------------------------------------------------------------------------");
	puts("[УВАГА] - Знаходження найменшого значення відносної похибки моделі...");
	index = find_min(array); // Пошук найиеншого числа в останній колонці таблиці
	printf("[ЗНАЙДЕНО] - %.3f в %d-му рядку таблиці", array[index].module, index + 1);
	process(array, arr, n, array[index].number); // Виклик функції, необхідної для 

	free(arr); // Звільнення пам'яті
	_getch(); // Завершення програми при натисканні
	return 0; // Завершення програми з кодом успіху
}

float sum_x(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження суми експериментальних даних по x
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += arr_arg[i].x;
	}
	return sum;
}

float sum_y(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження суми експериментальних даних по y
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += arr_arg[i].y;
	}
	return sum;
}

float sum_of_product(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження суми добутків експериментальних даних по x та y
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += arr_arg[i].x * arr_arg[i].y;
	}
	return sum;
}

float sum_of_xsquares(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження суми квадратів експериментальних даних по x
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += pow(arr_arg[i].x, 2);
	}
	return sum;
}

float sum_of_ysquares(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження суми квадратів експериментальних даних по y
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += pow(arr_arg[i].y, 2);
	}
	return sum;
}

void sorting_up(point* arr_arg, int n_arg) // Визначення функції, необхідної для сортування масиву за зростанням
{
	for (int i = 0; i < n_arg - 1; i++)
	{
		int min_index = i; // Ініціалізація найменшого елемента
		for (int j = i + 1; j < n_arg; j++)
		{
			// Знаходження меншого елемента
			if (arr_arg[j].x < arr_arg[min_index].x)
			{
				min_index = j;
			}
		}
		// Зміна елементів місцями
		point tmp = arr_arg[i];
		arr_arg[i] = arr_arg[min_index];
		arr_arg[min_index] = tmp;
	}
}

void sorting_down(point* arr_arg, int n_arg) // Визначення функції, необхідної для сортування масиву за спаданням
{
	for (int i = 0; i < n_arg - 1; i++)
	{
		int max_index = i; // Ініціалізація найбільшого елемента
		for (int j = i + 1; j < n_arg; j++)
		{
			// Знаходження більшого елемента
			if (arr_arg[j].x > arr_arg[max_index].x)
			{
				max_index = j;
			}
		}
		// Зміна елементів місцями
		point tmp = arr_arg[i];
		arr_arg[i] = arr_arg[max_index];
		arr_arg[max_index] = tmp;
	}
}

float average_x(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього арифметичного експериментальних даних по x
{
	return sum_x(arr_arg, n_arg) / n_arg;
}

float average_y(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього арифметичного експериментальних даних по y
{
	return sum_y(arr_arg, n_arg) / n_arg;
}

float average_geometric_x(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього геометричного експериментальних даних по x
{
	float product = 1;
	for (int i = 0; i < n_arg; i++)
	{
		product *= arr_arg[i].x;
	}
	return pow(product, 1.0 / n_arg);
}

float average_geometric_y(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього геометричного експериментальних даних по y
{
	float product = 1;
	for (int i = 0; i < n_arg; i++)
	{
		product *= arr_arg[i].y;
	}
	return pow(product, 1.0 / n_arg);
}

float average_garmonic_x(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього гармонійного експериментальних даних по x
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += 1 / arr_arg[i].x;
	}
	return n_arg / sum;
}

float average_garmonic_y(point* arr_arg, int n_arg) // Визначення функцій, необхідної для знаходження середнього гармонійного експериментальних даних по y
{
	float sum = 0;
	for (int i = 0; i < n_arg; i++)
	{
		sum += 1 / arr_arg[i].y;
	}
	return n_arg / sum;
}

void search(table array_arg[], point* arr_arg, int n_arg) // Визначення функції, необхідної для пошуку Y-регресивного та модуля
{
	for (int i = 0; i < 9; i++) // Оператор циклу for, прохід по кожному рядку таблиці
	{
		for (int j = 1; j < n_arg; j++) // Оператор циклу for, прохід по кожній точці
		{
			// Пошук місця серед експериментальних точок де лежить X_сер. 
			if (array_arg[i].x_average < arr_arg[j].x)
			{
				// Обчислення Y-рег.
				array_arg[i].y_regressive = (arr_arg[j - 1].y) + (((arr_arg[j].y - arr_arg[j - 1].y) / (arr_arg[j].x - arr_arg[j - 1].x)) * (array_arg[i].x_average - arr_arg[j - 1].x));
				break; // Вихід з циклу
			}
		}
		array_arg[i].module = fabs((array_arg[i].y_average - array_arg[i].y_regressive) / array_arg[i].y_regressive); // Обчислення значення для останньої колонки таблиці
	}
}

int find_min(table array_arg[]) // Визначення функції, необхідної для пошуку мінімального за значенням модуля
{
	float min = array_arg[0].module;
	int index = 0;
	for (int i = 1; i < 9; i++)
	{
		if (min > array_arg[i].module)
		{
			min = array_arg[i].module;
			index = i;
		}
	}
	return index;
}

void calculating_a1_a0(point* tmparr_arg, int n_arg, float* a1_arg, float* a0_arg) // Визначення функції, необхідної для знаходження коефіцієнтів a1 та a0
{
	*a1_arg = ((sum_of_product(tmparr_arg, n_arg)) - ((1.0 / n_arg) * (sum_x(tmparr_arg, n_arg) * sum_y(tmparr_arg, n_arg)))) / (sum_of_xsquares(tmparr_arg, n_arg) - (1.0 / n_arg * (pow(sum_x(tmparr_arg, n_arg), 2))));
	*a0_arg = ((1.0 / n_arg) * sum_y(tmparr_arg, n_arg)) - ((*a1_arg / n_arg) * sum_x(tmparr_arg, n_arg));
}

void process(table array_arg[], point* arr_arg, int n_arg, int index_arg) // Визначення функції, необхідної для визначення типу функції регресії та виводу результатів
{
	point* tmparr;
	float a1, a0, R_2, F, real_a0, real_a1;
	tmparr = (point*)malloc(n_arg * sizeof(point)); // Виділення пам'яті для копії масиву точок
	// Перевірка виділення пам'яті
	if (tmparr == NULL)
	{
		puts("\n-----------------------------------------------------------------------------------------");
		puts("[ПОМИЛКА] - Невдале виділення пам'яті!");
		puts("-----------------------------------------------------------------------------------------");
		exit(1); // Завершення програми з кодом помилки
	}
	// Копіювання елементів з одного масиву структур в інший
	for (int i = 0; i < n_arg; i++)
	{
		tmparr[i] = arr_arg[i];
	}
	// Визначення функції регресії
	if (index_arg == 1)
	{
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція регресії: y = %.3f + (%.3f * x)\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 2)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].x > 0)
			{
				tmparr[i].x = log(tmparr[i].x);
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (х <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція регресії: y = %.3f + (%.3f * ln(x))\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 3)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].x != 0)
			{
				tmparr[i].x = 1.0 / tmparr[i].x;
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція регресії: y = %.3f + (%.3f / x)\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 4)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y > 0) {
				tmparr[i].y = log(tmparr[i].y);
			}
			else 
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (y <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		real_a1 = exp(a1);
		real_a0 = exp(a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = %.3f * (%.3f^x)\n", real_a0, real_a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 5)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y > 0)
			{
				tmparr[i].y = log(tmparr[i].y);
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (y <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
			if (tmparr[i].x > 0)
			{
				tmparr[i].x = log(tmparr[i].x);
			}
			else 
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (х <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		real_a0 = exp(a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = %.3f * (x^%.3f)\n", real_a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 6)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y > 0)
			{
				tmparr[i].y = log(tmparr[i].y);
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (y <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
			if (tmparr[i].x != 0)
			{
				tmparr[i].x = 1.0 / tmparr[i].x;
			}
			else 
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = e^(%.3f + (%.3f / x))\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 7)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y != 0)
			{
				tmparr[i].y = 1.0 / tmparr[i].y;
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("\n-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = 1 / (%.3f + (%.3f * x))\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 8)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y != 0)
			{
				tmparr[i].y = 1.0 / tmparr[i].y;
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("-----------------------------------------------------------------------------------------");
			}
			if (tmparr[i].x > 0)
			{
				tmparr[i].x = log(tmparr[i].x);
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Логарифм обчислити неможливо! (х <= 0)");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = 1 / (%.3f + (%.3f * ln(x)))\n", a0, a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	else if (index_arg == 9)
	{
		for (int i = 0; i < n_arg; i++)
		{
			if (tmparr[i].y != 0)
			{
				tmparr[i].y = 1.0 / tmparr[i].y;
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("-----------------------------------------------------------------------------------------");
			}
			if (tmparr[i].x != 0)
			{
				tmparr[i].x = 1.0 / tmparr[i].x;
			}
			else
			{
				puts("\n-----------------------------------------------------------------------------------------");
				puts("[ПОМИЛКА] - Ділення на нуль!");
				puts("-----------------------------------------------------------------------------------------");
			}
		}
		calculating_a1_a0(tmparr, n_arg, &a1, &a0);
		real_a0 = a1;
		real_a1 = a0;
		puts("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\t\t\t\t~~РЕЗУЛЬТАТИ~~");
		puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
		puts("\n-----------------------------------------------------------------------------------------");
		printf("Отримана функція: y = x / (%.3f + (%.3f * x))\n", real_a0, real_a1);
		puts("-----------------------------------------------------------------------------------------");
	}
	// Обчислення критеріїй детермінованості та Фішера
	R_2 = (a1 * ((n_arg * sum_of_product(tmparr, n_arg)) - (sum_x(tmparr, n_arg) * sum_y(tmparr, n_arg)))) / ((n_arg * sum_of_ysquares(tmparr, n_arg)) - (pow(sum_y(tmparr, n_arg), 2)));
	F = (R_2 / (1 - R_2)) * ((n_arg - 1 - 1) / 1);
	puts("\n-----------------------------------------------------------------------------------------");
	printf("Коефіцієнт детермінованості: %.3f", R_2);
	printf("\nКритерій Фішера: %.3f\n", F);
	puts("-----------------------------------------------------------------------------------------");

	free(tmparr); // Звільнення пам'яті
}
